// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fmsmoov.proto

#ifndef PROTOBUF_fmsmoov_2eproto__INCLUDED
#define PROTOBUF_fmsmoov_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace fmsmoov {
class GainGetCommand;
class GainGetCommandDefaultTypeInternal;
extern GainGetCommandDefaultTypeInternal _GainGetCommand_default_instance_;
class GainGetResponse;
class GainGetResponseDefaultTypeInternal;
extern GainGetResponseDefaultTypeInternal _GainGetResponse_default_instance_;
class GainPair;
class GainPairDefaultTypeInternal;
extern GainPairDefaultTypeInternal _GainPair_default_instance_;
class GainSetCommand;
class GainSetCommandDefaultTypeInternal;
extern GainSetCommandDefaultTypeInternal _GainSetCommand_default_instance_;
class GainSetResponse;
class GainSetResponseDefaultTypeInternal;
extern GainSetResponseDefaultTypeInternal _GainSetResponse_default_instance_;
class ProcessorCommand;
class ProcessorCommandDefaultTypeInternal;
extern ProcessorCommandDefaultTypeInternal _ProcessorCommand_default_instance_;
class ProcessorLiveData;
class ProcessorLiveDataDefaultTypeInternal;
extern ProcessorLiveDataDefaultTypeInternal _ProcessorLiveData_default_instance_;
class ProcessorResponse;
class ProcessorResponseDefaultTypeInternal;
extern ProcessorResponseDefaultTypeInternal _ProcessorResponse_default_instance_;
}  // namespace fmsmoov

namespace fmsmoov {

namespace protobuf_fmsmoov_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_fmsmoov_2eproto

enum GainType {
  LINEAR = 0,
  LOG = 1,
  GainType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GainType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GainType_IsValid(int value);
const GainType GainType_MIN = LINEAR;
const GainType GainType_MAX = LOG;
const int GainType_ARRAYSIZE = GainType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GainType_descriptor();
inline const ::std::string& GainType_Name(GainType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GainType_descriptor(), value);
}
inline bool GainType_Parse(
    const ::std::string& name, GainType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GainType>(
    GainType_descriptor(), name, value);
}
enum ResponseCode {
  OK = 0,
  ERROR = 1,
  ResponseCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ResponseCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ResponseCode_IsValid(int value);
const ResponseCode ResponseCode_MIN = OK;
const ResponseCode ResponseCode_MAX = ERROR;
const int ResponseCode_ARRAYSIZE = ResponseCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResponseCode_descriptor();
inline const ::std::string& ResponseCode_Name(ResponseCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResponseCode_descriptor(), value);
}
inline bool ResponseCode_Parse(
    const ::std::string& name, ResponseCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseCode>(
    ResponseCode_descriptor(), name, value);
}
// ===================================================================

class GainPair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fmsmoov.GainPair) */ {
 public:
  GainPair();
  virtual ~GainPair();

  GainPair(const GainPair& from);

  inline GainPair& operator=(const GainPair& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GainPair& default_instance();

  static inline const GainPair* internal_default_instance() {
    return reinterpret_cast<const GainPair*>(
               &_GainPair_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(GainPair* other);

  // implements Message ----------------------------------------------

  inline GainPair* New() const PROTOBUF_FINAL { return New(NULL); }

  GainPair* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GainPair& from);
  void MergeFrom(const GainPair& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GainPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float l = 1;
  void clear_l();
  static const int kLFieldNumber = 1;
  float l() const;
  void set_l(float value);

  // float r = 2;
  void clear_r();
  static const int kRFieldNumber = 2;
  float r() const;
  void set_r(float value);

  // @@protoc_insertion_point(class_scope:fmsmoov.GainPair)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float l_;
  float r_;
  mutable int _cached_size_;
  friend struct protobuf_fmsmoov_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcessorLiveData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fmsmoov.ProcessorLiveData) */ {
 public:
  ProcessorLiveData();
  virtual ~ProcessorLiveData();

  ProcessorLiveData(const ProcessorLiveData& from);

  inline ProcessorLiveData& operator=(const ProcessorLiveData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessorLiveData& default_instance();

  static inline const ProcessorLiveData* internal_default_instance() {
    return reinterpret_cast<const ProcessorLiveData*>(
               &_ProcessorLiveData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ProcessorLiveData* other);

  // implements Message ----------------------------------------------

  inline ProcessorLiveData* New() const PROTOBUF_FINAL { return New(NULL); }

  ProcessorLiveData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProcessorLiveData& from);
  void MergeFrom(const ProcessorLiveData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProcessorLiveData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float inL = 1;
  void clear_inl();
  static const int kInLFieldNumber = 1;
  float inl() const;
  void set_inl(float value);

  // float inR = 2;
  void clear_inr();
  static const int kInRFieldNumber = 2;
  float inr() const;
  void set_inr(float value);

  // float outL = 3;
  void clear_outl();
  static const int kOutLFieldNumber = 3;
  float outl() const;
  void set_outl(float value);

  // float outR = 4;
  void clear_outr();
  static const int kOutRFieldNumber = 4;
  float outr() const;
  void set_outr(float value);

  // @@protoc_insertion_point(class_scope:fmsmoov.ProcessorLiveData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float inl_;
  float inr_;
  float outl_;
  float outr_;
  mutable int _cached_size_;
  friend struct protobuf_fmsmoov_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GainSetCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fmsmoov.GainSetCommand) */ {
 public:
  GainSetCommand();
  virtual ~GainSetCommand();

  GainSetCommand(const GainSetCommand& from);

  inline GainSetCommand& operator=(const GainSetCommand& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GainSetCommand& default_instance();

  enum GaintypeOneofCase {
    kGainPair = 2,
    kGain = 3,
    GAINTYPE_ONEOF_NOT_SET = 0,
  };

  static inline const GainSetCommand* internal_default_instance() {
    return reinterpret_cast<const GainSetCommand*>(
               &_GainSetCommand_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(GainSetCommand* other);

  // implements Message ----------------------------------------------

  inline GainSetCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  GainSetCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GainSetCommand& from);
  void MergeFrom(const GainSetCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GainSetCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string which = 1;
  void clear_which();
  static const int kWhichFieldNumber = 1;
  const ::std::string& which() const;
  void set_which(const ::std::string& value);
  #if LANG_CXX11
  void set_which(::std::string&& value);
  #endif
  void set_which(const char* value);
  void set_which(const char* value, size_t size);
  ::std::string* mutable_which();
  ::std::string* release_which();
  void set_allocated_which(::std::string* which);

  // .fmsmoov.GainType type = 4;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::fmsmoov::GainType type() const;
  void set_type(::fmsmoov::GainType value);

  // .fmsmoov.GainPair gain_pair = 2;
  bool has_gain_pair() const;
  void clear_gain_pair();
  static const int kGainPairFieldNumber = 2;
  const ::fmsmoov::GainPair& gain_pair() const;
  ::fmsmoov::GainPair* mutable_gain_pair();
  ::fmsmoov::GainPair* release_gain_pair();
  void set_allocated_gain_pair(::fmsmoov::GainPair* gain_pair);

  // float gain = 3;
  private:
  bool has_gain() const;
  public:
  void clear_gain();
  static const int kGainFieldNumber = 3;
  float gain() const;
  void set_gain(float value);

  GaintypeOneofCase gaintype_oneof_case() const;
  // @@protoc_insertion_point(class_scope:fmsmoov.GainSetCommand)
 private:
  void set_has_gain_pair();
  void set_has_gain();

  inline bool has_gaintype_oneof() const;
  void clear_gaintype_oneof();
  inline void clear_has_gaintype_oneof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr which_;
  int type_;
  union GaintypeOneofUnion {
    GaintypeOneofUnion() {}
    ::fmsmoov::GainPair* gain_pair_;
    float gain_;
  } gaintype_oneof_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_fmsmoov_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GainSetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fmsmoov.GainSetResponse) */ {
 public:
  GainSetResponse();
  virtual ~GainSetResponse();

  GainSetResponse(const GainSetResponse& from);

  inline GainSetResponse& operator=(const GainSetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GainSetResponse& default_instance();

  static inline const GainSetResponse* internal_default_instance() {
    return reinterpret_cast<const GainSetResponse*>(
               &_GainSetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(GainSetResponse* other);

  // implements Message ----------------------------------------------

  inline GainSetResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GainSetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GainSetResponse& from);
  void MergeFrom(const GainSetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GainSetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .fmsmoov.ResponseCode response = 1;
  void clear_response();
  static const int kResponseFieldNumber = 1;
  ::fmsmoov::ResponseCode response() const;
  void set_response(::fmsmoov::ResponseCode value);

  // @@protoc_insertion_point(class_scope:fmsmoov.GainSetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int response_;
  mutable int _cached_size_;
  friend struct protobuf_fmsmoov_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GainGetCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fmsmoov.GainGetCommand) */ {
 public:
  GainGetCommand();
  virtual ~GainGetCommand();

  GainGetCommand(const GainGetCommand& from);

  inline GainGetCommand& operator=(const GainGetCommand& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GainGetCommand& default_instance();

  static inline const GainGetCommand* internal_default_instance() {
    return reinterpret_cast<const GainGetCommand*>(
               &_GainGetCommand_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(GainGetCommand* other);

  // implements Message ----------------------------------------------

  inline GainGetCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  GainGetCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GainGetCommand& from);
  void MergeFrom(const GainGetCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GainGetCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string which = 1;
  void clear_which();
  static const int kWhichFieldNumber = 1;
  const ::std::string& which() const;
  void set_which(const ::std::string& value);
  #if LANG_CXX11
  void set_which(::std::string&& value);
  #endif
  void set_which(const char* value);
  void set_which(const char* value, size_t size);
  ::std::string* mutable_which();
  ::std::string* release_which();
  void set_allocated_which(::std::string* which);

  // @@protoc_insertion_point(class_scope:fmsmoov.GainGetCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr which_;
  mutable int _cached_size_;
  friend struct protobuf_fmsmoov_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GainGetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fmsmoov.GainGetResponse) */ {
 public:
  GainGetResponse();
  virtual ~GainGetResponse();

  GainGetResponse(const GainGetResponse& from);

  inline GainGetResponse& operator=(const GainGetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GainGetResponse& default_instance();

  enum GaintypeOneofCase {
    kGainPair = 2,
    kGain = 3,
    GAINTYPE_ONEOF_NOT_SET = 0,
  };

  static inline const GainGetResponse* internal_default_instance() {
    return reinterpret_cast<const GainGetResponse*>(
               &_GainGetResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(GainGetResponse* other);

  // implements Message ----------------------------------------------

  inline GainGetResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GainGetResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GainGetResponse& from);
  void MergeFrom(const GainGetResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GainGetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string which = 1;
  void clear_which();
  static const int kWhichFieldNumber = 1;
  const ::std::string& which() const;
  void set_which(const ::std::string& value);
  #if LANG_CXX11
  void set_which(::std::string&& value);
  #endif
  void set_which(const char* value);
  void set_which(const char* value, size_t size);
  ::std::string* mutable_which();
  ::std::string* release_which();
  void set_allocated_which(::std::string* which);

  // .fmsmoov.GainType type = 4;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::fmsmoov::GainType type() const;
  void set_type(::fmsmoov::GainType value);

  // .fmsmoov.GainPair gain_pair = 2;
  bool has_gain_pair() const;
  void clear_gain_pair();
  static const int kGainPairFieldNumber = 2;
  const ::fmsmoov::GainPair& gain_pair() const;
  ::fmsmoov::GainPair* mutable_gain_pair();
  ::fmsmoov::GainPair* release_gain_pair();
  void set_allocated_gain_pair(::fmsmoov::GainPair* gain_pair);

  // float gain = 3;
  private:
  bool has_gain() const;
  public:
  void clear_gain();
  static const int kGainFieldNumber = 3;
  float gain() const;
  void set_gain(float value);

  GaintypeOneofCase gaintype_oneof_case() const;
  // @@protoc_insertion_point(class_scope:fmsmoov.GainGetResponse)
 private:
  void set_has_gain_pair();
  void set_has_gain();

  inline bool has_gaintype_oneof() const;
  void clear_gaintype_oneof();
  inline void clear_has_gaintype_oneof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr which_;
  int type_;
  union GaintypeOneofUnion {
    GaintypeOneofUnion() {}
    ::fmsmoov::GainPair* gain_pair_;
    float gain_;
  } gaintype_oneof_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_fmsmoov_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcessorCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fmsmoov.ProcessorCommand) */ {
 public:
  ProcessorCommand();
  virtual ~ProcessorCommand();

  ProcessorCommand(const ProcessorCommand& from);

  inline ProcessorCommand& operator=(const ProcessorCommand& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessorCommand& default_instance();

  enum CmdOneofCase {
    kGainSet = 1,
    kGainGet = 2,
    CMD_ONEOF_NOT_SET = 0,
  };

  static inline const ProcessorCommand* internal_default_instance() {
    return reinterpret_cast<const ProcessorCommand*>(
               &_ProcessorCommand_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ProcessorCommand* other);

  // implements Message ----------------------------------------------

  inline ProcessorCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  ProcessorCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProcessorCommand& from);
  void MergeFrom(const ProcessorCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProcessorCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .fmsmoov.GainSetCommand gain_set = 1;
  bool has_gain_set() const;
  void clear_gain_set();
  static const int kGainSetFieldNumber = 1;
  const ::fmsmoov::GainSetCommand& gain_set() const;
  ::fmsmoov::GainSetCommand* mutable_gain_set();
  ::fmsmoov::GainSetCommand* release_gain_set();
  void set_allocated_gain_set(::fmsmoov::GainSetCommand* gain_set);

  // .fmsmoov.GainGetCommand gain_get = 2;
  bool has_gain_get() const;
  void clear_gain_get();
  static const int kGainGetFieldNumber = 2;
  const ::fmsmoov::GainGetCommand& gain_get() const;
  ::fmsmoov::GainGetCommand* mutable_gain_get();
  ::fmsmoov::GainGetCommand* release_gain_get();
  void set_allocated_gain_get(::fmsmoov::GainGetCommand* gain_get);

  CmdOneofCase cmd_oneof_case() const;
  // @@protoc_insertion_point(class_scope:fmsmoov.ProcessorCommand)
 private:
  void set_has_gain_set();
  void set_has_gain_get();

  inline bool has_cmd_oneof() const;
  void clear_cmd_oneof();
  inline void clear_has_cmd_oneof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union CmdOneofUnion {
    CmdOneofUnion() {}
    ::fmsmoov::GainSetCommand* gain_set_;
    ::fmsmoov::GainGetCommand* gain_get_;
  } cmd_oneof_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_fmsmoov_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcessorResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fmsmoov.ProcessorResponse) */ {
 public:
  ProcessorResponse();
  virtual ~ProcessorResponse();

  ProcessorResponse(const ProcessorResponse& from);

  inline ProcessorResponse& operator=(const ProcessorResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessorResponse& default_instance();

  enum RspOneofCase {
    kGainSet = 2,
    kGainGet = 3,
    RSP_ONEOF_NOT_SET = 0,
  };

  static inline const ProcessorResponse* internal_default_instance() {
    return reinterpret_cast<const ProcessorResponse*>(
               &_ProcessorResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ProcessorResponse* other);

  // implements Message ----------------------------------------------

  inline ProcessorResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ProcessorResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProcessorResponse& from);
  void MergeFrom(const ProcessorResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProcessorResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .fmsmoov.ResponseCode response = 1;
  void clear_response();
  static const int kResponseFieldNumber = 1;
  ::fmsmoov::ResponseCode response() const;
  void set_response(::fmsmoov::ResponseCode value);

  // .fmsmoov.GainSetResponse gain_set = 2;
  bool has_gain_set() const;
  void clear_gain_set();
  static const int kGainSetFieldNumber = 2;
  const ::fmsmoov::GainSetResponse& gain_set() const;
  ::fmsmoov::GainSetResponse* mutable_gain_set();
  ::fmsmoov::GainSetResponse* release_gain_set();
  void set_allocated_gain_set(::fmsmoov::GainSetResponse* gain_set);

  // .fmsmoov.GainGetResponse gain_get = 3;
  bool has_gain_get() const;
  void clear_gain_get();
  static const int kGainGetFieldNumber = 3;
  const ::fmsmoov::GainGetResponse& gain_get() const;
  ::fmsmoov::GainGetResponse* mutable_gain_get();
  ::fmsmoov::GainGetResponse* release_gain_get();
  void set_allocated_gain_get(::fmsmoov::GainGetResponse* gain_get);

  RspOneofCase rsp_oneof_case() const;
  // @@protoc_insertion_point(class_scope:fmsmoov.ProcessorResponse)
 private:
  void set_has_gain_set();
  void set_has_gain_get();

  inline bool has_rsp_oneof() const;
  void clear_rsp_oneof();
  inline void clear_has_rsp_oneof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int response_;
  union RspOneofUnion {
    RspOneofUnion() {}
    ::fmsmoov::GainSetResponse* gain_set_;
    ::fmsmoov::GainGetResponse* gain_get_;
  } rsp_oneof_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_fmsmoov_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// GainPair

// float l = 1;
inline void GainPair::clear_l() {
  l_ = 0;
}
inline float GainPair::l() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainPair.l)
  return l_;
}
inline void GainPair::set_l(float value) {
  
  l_ = value;
  // @@protoc_insertion_point(field_set:fmsmoov.GainPair.l)
}

// float r = 2;
inline void GainPair::clear_r() {
  r_ = 0;
}
inline float GainPair::r() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainPair.r)
  return r_;
}
inline void GainPair::set_r(float value) {
  
  r_ = value;
  // @@protoc_insertion_point(field_set:fmsmoov.GainPair.r)
}

// -------------------------------------------------------------------

// ProcessorLiveData

// float inL = 1;
inline void ProcessorLiveData::clear_inl() {
  inl_ = 0;
}
inline float ProcessorLiveData::inl() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorLiveData.inL)
  return inl_;
}
inline void ProcessorLiveData::set_inl(float value) {
  
  inl_ = value;
  // @@protoc_insertion_point(field_set:fmsmoov.ProcessorLiveData.inL)
}

// float inR = 2;
inline void ProcessorLiveData::clear_inr() {
  inr_ = 0;
}
inline float ProcessorLiveData::inr() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorLiveData.inR)
  return inr_;
}
inline void ProcessorLiveData::set_inr(float value) {
  
  inr_ = value;
  // @@protoc_insertion_point(field_set:fmsmoov.ProcessorLiveData.inR)
}

// float outL = 3;
inline void ProcessorLiveData::clear_outl() {
  outl_ = 0;
}
inline float ProcessorLiveData::outl() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorLiveData.outL)
  return outl_;
}
inline void ProcessorLiveData::set_outl(float value) {
  
  outl_ = value;
  // @@protoc_insertion_point(field_set:fmsmoov.ProcessorLiveData.outL)
}

// float outR = 4;
inline void ProcessorLiveData::clear_outr() {
  outr_ = 0;
}
inline float ProcessorLiveData::outr() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorLiveData.outR)
  return outr_;
}
inline void ProcessorLiveData::set_outr(float value) {
  
  outr_ = value;
  // @@protoc_insertion_point(field_set:fmsmoov.ProcessorLiveData.outR)
}

// -------------------------------------------------------------------

// GainSetCommand

// string which = 1;
inline void GainSetCommand::clear_which() {
  which_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GainSetCommand::which() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainSetCommand.which)
  return which_.GetNoArena();
}
inline void GainSetCommand::set_which(const ::std::string& value) {
  
  which_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fmsmoov.GainSetCommand.which)
}
#if LANG_CXX11
inline void GainSetCommand::set_which(::std::string&& value) {
  
  which_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fmsmoov.GainSetCommand.which)
}
#endif
inline void GainSetCommand::set_which(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  which_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fmsmoov.GainSetCommand.which)
}
inline void GainSetCommand::set_which(const char* value, size_t size) {
  
  which_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fmsmoov.GainSetCommand.which)
}
inline ::std::string* GainSetCommand::mutable_which() {
  
  // @@protoc_insertion_point(field_mutable:fmsmoov.GainSetCommand.which)
  return which_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GainSetCommand::release_which() {
  // @@protoc_insertion_point(field_release:fmsmoov.GainSetCommand.which)
  
  return which_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GainSetCommand::set_allocated_which(::std::string* which) {
  if (which != NULL) {
    
  } else {
    
  }
  which_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), which);
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.GainSetCommand.which)
}

// .fmsmoov.GainPair gain_pair = 2;
inline bool GainSetCommand::has_gain_pair() const {
  return gaintype_oneof_case() == kGainPair;
}
inline void GainSetCommand::set_has_gain_pair() {
  _oneof_case_[0] = kGainPair;
}
inline void GainSetCommand::clear_gain_pair() {
  if (has_gain_pair()) {
    delete gaintype_oneof_.gain_pair_;
    clear_has_gaintype_oneof();
  }
}
inline  const ::fmsmoov::GainPair& GainSetCommand::gain_pair() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainSetCommand.gain_pair)
  return has_gain_pair()
      ? *gaintype_oneof_.gain_pair_
      : ::fmsmoov::GainPair::default_instance();
}
inline ::fmsmoov::GainPair* GainSetCommand::mutable_gain_pair() {
  if (!has_gain_pair()) {
    clear_gaintype_oneof();
    set_has_gain_pair();
    gaintype_oneof_.gain_pair_ = new ::fmsmoov::GainPair;
  }
  // @@protoc_insertion_point(field_mutable:fmsmoov.GainSetCommand.gain_pair)
  return gaintype_oneof_.gain_pair_;
}
inline ::fmsmoov::GainPair* GainSetCommand::release_gain_pair() {
  // @@protoc_insertion_point(field_release:fmsmoov.GainSetCommand.gain_pair)
  if (has_gain_pair()) {
    clear_has_gaintype_oneof();
    ::fmsmoov::GainPair* temp = gaintype_oneof_.gain_pair_;
    gaintype_oneof_.gain_pair_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GainSetCommand::set_allocated_gain_pair(::fmsmoov::GainPair* gain_pair) {
  clear_gaintype_oneof();
  if (gain_pair) {
    set_has_gain_pair();
    gaintype_oneof_.gain_pair_ = gain_pair;
  }
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.GainSetCommand.gain_pair)
}

// float gain = 3;
inline bool GainSetCommand::has_gain() const {
  return gaintype_oneof_case() == kGain;
}
inline void GainSetCommand::set_has_gain() {
  _oneof_case_[0] = kGain;
}
inline void GainSetCommand::clear_gain() {
  if (has_gain()) {
    gaintype_oneof_.gain_ = 0;
    clear_has_gaintype_oneof();
  }
}
inline float GainSetCommand::gain() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainSetCommand.gain)
  if (has_gain()) {
    return gaintype_oneof_.gain_;
  }
  return 0;
}
inline void GainSetCommand::set_gain(float value) {
  if (!has_gain()) {
    clear_gaintype_oneof();
    set_has_gain();
  }
  gaintype_oneof_.gain_ = value;
  // @@protoc_insertion_point(field_set:fmsmoov.GainSetCommand.gain)
}

// .fmsmoov.GainType type = 4;
inline void GainSetCommand::clear_type() {
  type_ = 0;
}
inline ::fmsmoov::GainType GainSetCommand::type() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainSetCommand.type)
  return static_cast< ::fmsmoov::GainType >(type_);
}
inline void GainSetCommand::set_type(::fmsmoov::GainType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:fmsmoov.GainSetCommand.type)
}

inline bool GainSetCommand::has_gaintype_oneof() const {
  return gaintype_oneof_case() != GAINTYPE_ONEOF_NOT_SET;
}
inline void GainSetCommand::clear_has_gaintype_oneof() {
  _oneof_case_[0] = GAINTYPE_ONEOF_NOT_SET;
}
inline GainSetCommand::GaintypeOneofCase GainSetCommand::gaintype_oneof_case() const {
  return GainSetCommand::GaintypeOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GainSetResponse

// .fmsmoov.ResponseCode response = 1;
inline void GainSetResponse::clear_response() {
  response_ = 0;
}
inline ::fmsmoov::ResponseCode GainSetResponse::response() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainSetResponse.response)
  return static_cast< ::fmsmoov::ResponseCode >(response_);
}
inline void GainSetResponse::set_response(::fmsmoov::ResponseCode value) {
  
  response_ = value;
  // @@protoc_insertion_point(field_set:fmsmoov.GainSetResponse.response)
}

// -------------------------------------------------------------------

// GainGetCommand

// string which = 1;
inline void GainGetCommand::clear_which() {
  which_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GainGetCommand::which() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainGetCommand.which)
  return which_.GetNoArena();
}
inline void GainGetCommand::set_which(const ::std::string& value) {
  
  which_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fmsmoov.GainGetCommand.which)
}
#if LANG_CXX11
inline void GainGetCommand::set_which(::std::string&& value) {
  
  which_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fmsmoov.GainGetCommand.which)
}
#endif
inline void GainGetCommand::set_which(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  which_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fmsmoov.GainGetCommand.which)
}
inline void GainGetCommand::set_which(const char* value, size_t size) {
  
  which_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fmsmoov.GainGetCommand.which)
}
inline ::std::string* GainGetCommand::mutable_which() {
  
  // @@protoc_insertion_point(field_mutable:fmsmoov.GainGetCommand.which)
  return which_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GainGetCommand::release_which() {
  // @@protoc_insertion_point(field_release:fmsmoov.GainGetCommand.which)
  
  return which_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GainGetCommand::set_allocated_which(::std::string* which) {
  if (which != NULL) {
    
  } else {
    
  }
  which_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), which);
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.GainGetCommand.which)
}

// -------------------------------------------------------------------

// GainGetResponse

// string which = 1;
inline void GainGetResponse::clear_which() {
  which_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GainGetResponse::which() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainGetResponse.which)
  return which_.GetNoArena();
}
inline void GainGetResponse::set_which(const ::std::string& value) {
  
  which_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:fmsmoov.GainGetResponse.which)
}
#if LANG_CXX11
inline void GainGetResponse::set_which(::std::string&& value) {
  
  which_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:fmsmoov.GainGetResponse.which)
}
#endif
inline void GainGetResponse::set_which(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  which_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:fmsmoov.GainGetResponse.which)
}
inline void GainGetResponse::set_which(const char* value, size_t size) {
  
  which_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:fmsmoov.GainGetResponse.which)
}
inline ::std::string* GainGetResponse::mutable_which() {
  
  // @@protoc_insertion_point(field_mutable:fmsmoov.GainGetResponse.which)
  return which_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GainGetResponse::release_which() {
  // @@protoc_insertion_point(field_release:fmsmoov.GainGetResponse.which)
  
  return which_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GainGetResponse::set_allocated_which(::std::string* which) {
  if (which != NULL) {
    
  } else {
    
  }
  which_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), which);
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.GainGetResponse.which)
}

// .fmsmoov.GainPair gain_pair = 2;
inline bool GainGetResponse::has_gain_pair() const {
  return gaintype_oneof_case() == kGainPair;
}
inline void GainGetResponse::set_has_gain_pair() {
  _oneof_case_[0] = kGainPair;
}
inline void GainGetResponse::clear_gain_pair() {
  if (has_gain_pair()) {
    delete gaintype_oneof_.gain_pair_;
    clear_has_gaintype_oneof();
  }
}
inline  const ::fmsmoov::GainPair& GainGetResponse::gain_pair() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainGetResponse.gain_pair)
  return has_gain_pair()
      ? *gaintype_oneof_.gain_pair_
      : ::fmsmoov::GainPair::default_instance();
}
inline ::fmsmoov::GainPair* GainGetResponse::mutable_gain_pair() {
  if (!has_gain_pair()) {
    clear_gaintype_oneof();
    set_has_gain_pair();
    gaintype_oneof_.gain_pair_ = new ::fmsmoov::GainPair;
  }
  // @@protoc_insertion_point(field_mutable:fmsmoov.GainGetResponse.gain_pair)
  return gaintype_oneof_.gain_pair_;
}
inline ::fmsmoov::GainPair* GainGetResponse::release_gain_pair() {
  // @@protoc_insertion_point(field_release:fmsmoov.GainGetResponse.gain_pair)
  if (has_gain_pair()) {
    clear_has_gaintype_oneof();
    ::fmsmoov::GainPair* temp = gaintype_oneof_.gain_pair_;
    gaintype_oneof_.gain_pair_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GainGetResponse::set_allocated_gain_pair(::fmsmoov::GainPair* gain_pair) {
  clear_gaintype_oneof();
  if (gain_pair) {
    set_has_gain_pair();
    gaintype_oneof_.gain_pair_ = gain_pair;
  }
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.GainGetResponse.gain_pair)
}

// float gain = 3;
inline bool GainGetResponse::has_gain() const {
  return gaintype_oneof_case() == kGain;
}
inline void GainGetResponse::set_has_gain() {
  _oneof_case_[0] = kGain;
}
inline void GainGetResponse::clear_gain() {
  if (has_gain()) {
    gaintype_oneof_.gain_ = 0;
    clear_has_gaintype_oneof();
  }
}
inline float GainGetResponse::gain() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainGetResponse.gain)
  if (has_gain()) {
    return gaintype_oneof_.gain_;
  }
  return 0;
}
inline void GainGetResponse::set_gain(float value) {
  if (!has_gain()) {
    clear_gaintype_oneof();
    set_has_gain();
  }
  gaintype_oneof_.gain_ = value;
  // @@protoc_insertion_point(field_set:fmsmoov.GainGetResponse.gain)
}

// .fmsmoov.GainType type = 4;
inline void GainGetResponse::clear_type() {
  type_ = 0;
}
inline ::fmsmoov::GainType GainGetResponse::type() const {
  // @@protoc_insertion_point(field_get:fmsmoov.GainGetResponse.type)
  return static_cast< ::fmsmoov::GainType >(type_);
}
inline void GainGetResponse::set_type(::fmsmoov::GainType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:fmsmoov.GainGetResponse.type)
}

inline bool GainGetResponse::has_gaintype_oneof() const {
  return gaintype_oneof_case() != GAINTYPE_ONEOF_NOT_SET;
}
inline void GainGetResponse::clear_has_gaintype_oneof() {
  _oneof_case_[0] = GAINTYPE_ONEOF_NOT_SET;
}
inline GainGetResponse::GaintypeOneofCase GainGetResponse::gaintype_oneof_case() const {
  return GainGetResponse::GaintypeOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProcessorCommand

// .fmsmoov.GainSetCommand gain_set = 1;
inline bool ProcessorCommand::has_gain_set() const {
  return cmd_oneof_case() == kGainSet;
}
inline void ProcessorCommand::set_has_gain_set() {
  _oneof_case_[0] = kGainSet;
}
inline void ProcessorCommand::clear_gain_set() {
  if (has_gain_set()) {
    delete cmd_oneof_.gain_set_;
    clear_has_cmd_oneof();
  }
}
inline  const ::fmsmoov::GainSetCommand& ProcessorCommand::gain_set() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorCommand.gain_set)
  return has_gain_set()
      ? *cmd_oneof_.gain_set_
      : ::fmsmoov::GainSetCommand::default_instance();
}
inline ::fmsmoov::GainSetCommand* ProcessorCommand::mutable_gain_set() {
  if (!has_gain_set()) {
    clear_cmd_oneof();
    set_has_gain_set();
    cmd_oneof_.gain_set_ = new ::fmsmoov::GainSetCommand;
  }
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorCommand.gain_set)
  return cmd_oneof_.gain_set_;
}
inline ::fmsmoov::GainSetCommand* ProcessorCommand::release_gain_set() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorCommand.gain_set)
  if (has_gain_set()) {
    clear_has_cmd_oneof();
    ::fmsmoov::GainSetCommand* temp = cmd_oneof_.gain_set_;
    cmd_oneof_.gain_set_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ProcessorCommand::set_allocated_gain_set(::fmsmoov::GainSetCommand* gain_set) {
  clear_cmd_oneof();
  if (gain_set) {
    set_has_gain_set();
    cmd_oneof_.gain_set_ = gain_set;
  }
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.ProcessorCommand.gain_set)
}

// .fmsmoov.GainGetCommand gain_get = 2;
inline bool ProcessorCommand::has_gain_get() const {
  return cmd_oneof_case() == kGainGet;
}
inline void ProcessorCommand::set_has_gain_get() {
  _oneof_case_[0] = kGainGet;
}
inline void ProcessorCommand::clear_gain_get() {
  if (has_gain_get()) {
    delete cmd_oneof_.gain_get_;
    clear_has_cmd_oneof();
  }
}
inline  const ::fmsmoov::GainGetCommand& ProcessorCommand::gain_get() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorCommand.gain_get)
  return has_gain_get()
      ? *cmd_oneof_.gain_get_
      : ::fmsmoov::GainGetCommand::default_instance();
}
inline ::fmsmoov::GainGetCommand* ProcessorCommand::mutable_gain_get() {
  if (!has_gain_get()) {
    clear_cmd_oneof();
    set_has_gain_get();
    cmd_oneof_.gain_get_ = new ::fmsmoov::GainGetCommand;
  }
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorCommand.gain_get)
  return cmd_oneof_.gain_get_;
}
inline ::fmsmoov::GainGetCommand* ProcessorCommand::release_gain_get() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorCommand.gain_get)
  if (has_gain_get()) {
    clear_has_cmd_oneof();
    ::fmsmoov::GainGetCommand* temp = cmd_oneof_.gain_get_;
    cmd_oneof_.gain_get_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ProcessorCommand::set_allocated_gain_get(::fmsmoov::GainGetCommand* gain_get) {
  clear_cmd_oneof();
  if (gain_get) {
    set_has_gain_get();
    cmd_oneof_.gain_get_ = gain_get;
  }
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.ProcessorCommand.gain_get)
}

inline bool ProcessorCommand::has_cmd_oneof() const {
  return cmd_oneof_case() != CMD_ONEOF_NOT_SET;
}
inline void ProcessorCommand::clear_has_cmd_oneof() {
  _oneof_case_[0] = CMD_ONEOF_NOT_SET;
}
inline ProcessorCommand::CmdOneofCase ProcessorCommand::cmd_oneof_case() const {
  return ProcessorCommand::CmdOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProcessorResponse

// .fmsmoov.ResponseCode response = 1;
inline void ProcessorResponse::clear_response() {
  response_ = 0;
}
inline ::fmsmoov::ResponseCode ProcessorResponse::response() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorResponse.response)
  return static_cast< ::fmsmoov::ResponseCode >(response_);
}
inline void ProcessorResponse::set_response(::fmsmoov::ResponseCode value) {
  
  response_ = value;
  // @@protoc_insertion_point(field_set:fmsmoov.ProcessorResponse.response)
}

// .fmsmoov.GainSetResponse gain_set = 2;
inline bool ProcessorResponse::has_gain_set() const {
  return rsp_oneof_case() == kGainSet;
}
inline void ProcessorResponse::set_has_gain_set() {
  _oneof_case_[0] = kGainSet;
}
inline void ProcessorResponse::clear_gain_set() {
  if (has_gain_set()) {
    delete rsp_oneof_.gain_set_;
    clear_has_rsp_oneof();
  }
}
inline  const ::fmsmoov::GainSetResponse& ProcessorResponse::gain_set() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorResponse.gain_set)
  return has_gain_set()
      ? *rsp_oneof_.gain_set_
      : ::fmsmoov::GainSetResponse::default_instance();
}
inline ::fmsmoov::GainSetResponse* ProcessorResponse::mutable_gain_set() {
  if (!has_gain_set()) {
    clear_rsp_oneof();
    set_has_gain_set();
    rsp_oneof_.gain_set_ = new ::fmsmoov::GainSetResponse;
  }
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorResponse.gain_set)
  return rsp_oneof_.gain_set_;
}
inline ::fmsmoov::GainSetResponse* ProcessorResponse::release_gain_set() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorResponse.gain_set)
  if (has_gain_set()) {
    clear_has_rsp_oneof();
    ::fmsmoov::GainSetResponse* temp = rsp_oneof_.gain_set_;
    rsp_oneof_.gain_set_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ProcessorResponse::set_allocated_gain_set(::fmsmoov::GainSetResponse* gain_set) {
  clear_rsp_oneof();
  if (gain_set) {
    set_has_gain_set();
    rsp_oneof_.gain_set_ = gain_set;
  }
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.ProcessorResponse.gain_set)
}

// .fmsmoov.GainGetResponse gain_get = 3;
inline bool ProcessorResponse::has_gain_get() const {
  return rsp_oneof_case() == kGainGet;
}
inline void ProcessorResponse::set_has_gain_get() {
  _oneof_case_[0] = kGainGet;
}
inline void ProcessorResponse::clear_gain_get() {
  if (has_gain_get()) {
    delete rsp_oneof_.gain_get_;
    clear_has_rsp_oneof();
  }
}
inline  const ::fmsmoov::GainGetResponse& ProcessorResponse::gain_get() const {
  // @@protoc_insertion_point(field_get:fmsmoov.ProcessorResponse.gain_get)
  return has_gain_get()
      ? *rsp_oneof_.gain_get_
      : ::fmsmoov::GainGetResponse::default_instance();
}
inline ::fmsmoov::GainGetResponse* ProcessorResponse::mutable_gain_get() {
  if (!has_gain_get()) {
    clear_rsp_oneof();
    set_has_gain_get();
    rsp_oneof_.gain_get_ = new ::fmsmoov::GainGetResponse;
  }
  // @@protoc_insertion_point(field_mutable:fmsmoov.ProcessorResponse.gain_get)
  return rsp_oneof_.gain_get_;
}
inline ::fmsmoov::GainGetResponse* ProcessorResponse::release_gain_get() {
  // @@protoc_insertion_point(field_release:fmsmoov.ProcessorResponse.gain_get)
  if (has_gain_get()) {
    clear_has_rsp_oneof();
    ::fmsmoov::GainGetResponse* temp = rsp_oneof_.gain_get_;
    rsp_oneof_.gain_get_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ProcessorResponse::set_allocated_gain_get(::fmsmoov::GainGetResponse* gain_get) {
  clear_rsp_oneof();
  if (gain_get) {
    set_has_gain_get();
    rsp_oneof_.gain_get_ = gain_get;
  }
  // @@protoc_insertion_point(field_set_allocated:fmsmoov.ProcessorResponse.gain_get)
}

inline bool ProcessorResponse::has_rsp_oneof() const {
  return rsp_oneof_case() != RSP_ONEOF_NOT_SET;
}
inline void ProcessorResponse::clear_has_rsp_oneof() {
  _oneof_case_[0] = RSP_ONEOF_NOT_SET;
}
inline ProcessorResponse::RspOneofCase ProcessorResponse::rsp_oneof_case() const {
  return ProcessorResponse::RspOneofCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace fmsmoov

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::fmsmoov::GainType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fmsmoov::GainType>() {
  return ::fmsmoov::GainType_descriptor();
}
template <> struct is_proto_enum< ::fmsmoov::ResponseCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fmsmoov::ResponseCode>() {
  return ::fmsmoov::ResponseCode_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_fmsmoov_2eproto__INCLUDED
